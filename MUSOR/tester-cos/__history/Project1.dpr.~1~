program Project1;

{$APPTYPE CONSOLE}

uses
  SysUtils,
  Windows;

type
  {Тип ключа (тип основных данных) узла дерева.}
  TData = Integer;
  {Тип указателя на узел.}
  TPNode = ^TNode;
  {Тип узла дерева.}
  TNode = record
    Data : TData; {Ключ (основные данные) узла дерева.}
    PLeft, PRight : TPNode; {Указатели на левый и правый узел.}
  end;

{Рекурсивная процедура для построения дерева через пользовательский ввод.
aPNode - переменная-указатель, обозначающая создаваемый узел.
aName - имя узла. Этот параметр предназначен для удобства ввода.
aName = '0' - корневой узел дерева;
aName = '0-1' - левый узел, связанный с корневым узлом.
aName = '0-2' - правый узел, связанный с корневым узлом.
И т. д.
Пример именования узлов дерева:
                   0
               /       \
           0-1           0-2
         /     \       /     \
      0-1-1  0-1-2  0-2-1  0-2-2
     /     \              /     \
 0-1-1-1  0-1-1-2     0-2-2-1  0-2-2-2       }
procedure ReadTree(var aPNode : TPNode; const aName : String);
var
  Data : TData;
  Code : Integer;
  S : String;
begin
  {Предлагаем пользователю создать узел.}
  Write('Узел ', aName, '. Ключ: ');
  Readln(S);
  if S <> '' then {Если пользователь согласился создать узел.}
  repeat
    Val(S, Data, Code); {Преобразуем строковое значение в числовое.}
    if Code = 0 then {Если ключ задан правильно.}
    begin
      {Создаём узел.}
      New(aPNode); {Выделяем память для узла.}
      aPNode^.Data := Data;  {Записываем в узел значение ключа.}
      aPNode^.PLeft := nil;  {Обнуляем указатель на левого потомка.}
      aPNode^.PRight := nil; {Обнуляем указатель на правого потомка.}
      {Рекурсивный вызов диалога создания левого потомка.}
      ReadTree(aPNode^.PLeft, aName + '-1');
      {Рекурсивный вызов диалога создания правого потомка.}
      ReadTree(aPNode^.PRight, aName + '-2');
    end
    else {Если ключ задан НЕправильно.}
      Writeln('Неверный ввод. Следует ввести целое число. Повторите.');
  until Code = 0;
end;

{Рекурсивная процедура для освобождения памяти, занятой деревом. (Удаление дерева).}
procedure TreeFree(var aPNode : TPNode);
begin
  if aPNode = nil then
    Exit;
  TreeFree(aPNode^.PLeft); {Рекурсивный вызов для освобождения памяти в левой ветви.}
  TreeFree(aPNode^.PRight); {Рекурсивный вызов для освобождения памяти в правой ветви.}
  Dispose(aPNode); {Освобождение памяти, занятой для текущего узла.}
  aPNode := nil; {Обнуление указателя на текущий узел.}
end;

{Рекурсивная процедура для распечатки узлов дерева. С обходом слева-направо.}
procedure WritelnNode(const aPNode : TPNode; const aName : String);
begin
  if aPNode = nil then
    Exit;
  Writeln(aName, ': ', aPNode^.Data);
  WritelnNode(aPNode^.PLeft, aName + '-1');
  WritelnNode(aPNode^.PRight, aName + '-2');
end;

var
  PTree : TPNode;
  Cmd, Code : Integer;
  S : String;
begin
  {Переключение окна консоли на кодовую страницу CP1251 (Win-1251).
  Если после переключения русские буквы показываются неверно,
  следует открыть системное меню консольного окна - щелчком мыши в левом
  верхнем углу окна консоли и выбрать:
  Свойства - закладка "Шрифт" - выбрать шрифт: "Lucida Console".}
  SetConsoleCP(1251);
  SetConsoleOutputCP(1251);

  {Начальная инициализация дерева.}
  PTree := nil;

  repeat
    {Меню}
    Writeln('----------');
    Writeln('Выберите действие:');
    Writeln('1: Создать дерево.');
    Writeln('2: Проверить дерево на пустоту.');
    Writeln('3: Распечатка узлов дерева с обходом слева-направо.');
    Writeln('4: Удалить дерево.');
    Writeln('5: Выход.');
    Write('Задайте команду: ');
    Readln(S);
    Val(S, Cmd, Code);
    if Code <> 0 then
      Cmd := -1;
    case Cmd of
      1:
      begin
        Writeln('Ввод дерева.');
        Writeln('Программа будет сама предлагать вам ввод узлов. Если вы согласны');
        Writeln('создать предложенный узел, то задайте его значение и нажмите Enter.');
        Writeln('Чтобы отказаться от создания узла оставьте пустую строку и нажмите Enter.');
        TreeFree(PTree);
        ReadTree(PTree, '0');
        Write('Ввод дерева завершён.');
      end;
      2:
      begin
        if PTree <> nil then
          Write('Дерево не пустое.')
        else
          Write('Дерево пустое.');
      end;
      3:
      begin
        WritelnNode(PTree, '0');
        Write('Конец распечатки.');
      end;
      4, 5:
      begin
        TreeFree(PTree);
        Write('Дерево удалено (память освобождена).');
      end;
      else
        Write('Незарегистрированная команда. Повторите ввод.');
    end;
    Readln;
  until Cmd = 5;

  Write('Работа программы завершена. Для выхода нажмите Enter.');
  Readln;
end.
