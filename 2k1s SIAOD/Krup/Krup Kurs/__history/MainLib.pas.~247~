unit MainLib;

interface
uses
  System.SysUtils,
  Vcl.Dialogs;


Type
  TData = Integer; { “ип указател€ на узел. }
  TPNode = ^TNode; { “ип узла дерева. }

  TNode = record
    Data: TData; {  люч (основные данные) узла дерева. }
    PLeft, PRight: TPNode; { ”казатели на левый и правый узел. }
end;

var
  PTree : TPNode;
  visit: array [1..100] of boolean;
  out_arr: array of integer;
  C: array[1..100] of array[1..100] of integer;
  C_BFS: array[1..100] of array[1..100] of integer;
  i :integer;

procedure BFS(v:integer; n:integer);
procedure Prim(out Way, Wght:string; n:integer);
procedure AddNode(var aPNode: TPNode; const aData, bData: TData);
implementation

procedure Prim(out Way, Wght:string; n:integer);
  var
  visited: array[1..10] of integer;  //массив посещенных/непосещенных вершин
  cost: array[1..10, 1..10] of integer;  //матрица смежности
  a, b, u, v, i, j, ne, min, path_index, mincost:integer;
  ti, tj:integer;
  outStr : String;
  path: array[1..100] of integer;
begin
  outStr := '1, ';
  path_index := 1;
  ne := 1;
  min := maxint; // макс значение дл€ integer. 4 байта ~ 43*10^8.
                  {»сп как вес дл€ дороги, которую точно следует
                  обойти в поиске наименьшего пути.  ак будто этой дороги и нету}
  mincost := 0;

  for i := 1 to 10 do  // «адаем всем вершинам показатель посещени€ в 0
    visited[i] := 0;

  for i := 1 to n do
    for j := 1 to n do  // переносим все из матрицы на форме в матрицу-структуру данных
    begin
      cost[i,j] := C[i,j];
      if (cost[i,j] = 0) then
        cost[i, j] := maxint;
    end;

    visited[1] := 1;   // посещаем первую вершину

    while (ne < n) do  // ѕродолжаем пока не поситим все вершины
    begin
      min := maxint;
      for i := 1 to n do
      begin
        for j := 1 to n do
          if cost[i,j] < min then  // ≈сли дорога существует
            if visited[i] <> 0 then   // ѕровер€ем посещена вершина или нет. ≈сли да, то все это дело запоминаем все это дело
            begin
              min := cost[i,j];
              u := i;
              a := u;

              v := j;
              b := v;
            end;
      end;
        if (visited[u] = 0) or (visited[v] = 0) then  // провер€ем посещена вершина ab или ba
        begin
          path[path_index] := b;   // записывем вершину на вывод
          path_index := path_index + 1;
          ne := ne + 1;  // это, чтобы while не длилс€ бесконечно. —четчик
          mincost := mincost + min; // ќбновл€ем стоимость
          visited[b] := 1;   // маркеруем вершину
        end;
        cost[b,a] := maxint;   // “ут дороги нет
        cost[a,b] := cost[b,a];  //“ут тоже
      end;

        for i := 1 to n-1 do   // тут работаем только с выводом. Outstr - строка котора€ потом идет в memo
        begin
          outStr := OutStr + inttostr(path[i]);  // формируем строку на вывод
          if (i < n - 1) then   // ѕровер€ем может ли быть в строке после последнего '--> n ' какое-то число
            outStr := outStr + ', '; // если да, то в качестве разделител€ ставим -->
        end;

        Way := outStr; // это итоговый путь
        Wght := inttostr(mincost);  // это итоговый вес }
end;

procedure BFS(v:integer; n:integer);
  var
  Q: array [1..100] of integer;
  Un,Uk: integer;
  j, add_out: integer;

begin
Un:=0; Uk:=0;
Uk:=Uk+1; Q[Uk]:=v;
add_out := 0;
Visit[v]:=false;
setlength(out_arr, n);

while Un < Uk do
begin
  Un:=Un+1; v:=Q[Un];
  inc(add_out);
  out_arr[add_out] := v;
    AddNode(PTree, v, Q[Uk]);
  for j:=0 to n do
    if (C_BFS[v,j]=1) and (Visit[j]) then
    begin
      Uk:=Uk+1; Q[Uk]:=j;
      Visit[j]:=false;
      AddNode(PTree, Q[Uk], v);
    end;
  end;
end;


procedure AddNode(var aPNode: TPNode; const aData, bData: TData);
begin
  if aPNode = nil then { ¬ставка узла. }
  begin
    New(aPNode); { ¬ыдел€ем пам€ть дл€ узла. }
    aPNode^.Data := aData; { «аписываем в узел значение ключа. }
    aPNode^.PLeft := nil; { ќбнул€ем указатель на левого потомка. }
    aPNode^.PRight := nil; { ќбнул€ем указатель на правого потомка. }
  end

  else if aPNode^.PLeft = nil then { ѕоиск места вставки в левой ветви. }
  begin
    //showMessage('left');
    AddNode(aPNode^.PRight, bData, bData);
    //NodeData := aPNode^.PLeft.Data;

  end

  else { ѕоиск места вставки в правой ветви. }
  begin
    //showMessage('right');
    AddNode(aPNode^.PLeft , aData , aData);
    //NodeData := aPNode^.PRight.Data;
  end;
end;

end.
