unit TreeLib;

interface

uses
  System.SysUtils;

implementation
type
  TData = Integer; { Тип указателя на узел. }
  TPNode = ^TNode; { Тип узла дерева. }

  TNode = record
    Data: TData; { Ключ (основные данные) узла дерева. }
    PLeft, PRight: TPNode; { Указатели на левый и правый узел. }
  end;
  TreeArrT = array[0..100] of TData;
var
  NodeData: integer;
  TreeHead: integer;
  InputData: string;
  PTree : TPNode;

  Data: TData;
  i:integer;


procedure AddNode(var aPNode: TPNode; const aData: TData);
begin
  if aPNode = nil then { Вставка узла. }
  begin
    New(aPNode); { Выделяем память для узла. }
    aPNode^.Data := aData; { Записываем в узел значение ключа. }
    aPNode^.PLeft := nil; { Обнуляем указатель на левого потомка. }
    aPNode^.PRight := nil; { Обнуляем указатель на правого потомка. }

    TreeHead := aData;
    //showMessage('1');
  end

  else if aData <= aPNode^.Data then { Поиск места вставки в левой ветви. }
  begin
    //showMessage('left');
    AddNode(aPNode^.PLeft, aData);
    //NodeData := aPNode^.PLeft.Data;

  end

  else if aData > aPNode^.Data then { Поиск места вставки в правой ветви. }
  begin
    //showMessage('right');
    AddNode(aPNode^.PRight, aData);
    //NodeData := aPNode^.PRight.Data;

  end;
end;

function TreeWrite(const aPNode : TPNode; WriteType:char): string;
begin
  if aPNode = nil then
    exit;

  if WriteType = 's' then
  begin
    TreeWrite(aPNode^.PLeft, WriteType);
    InputData := InputData + ' ' + inttostr(aPNode^.Data);
    TreeWrite(aPNode^.PRight, WriteType);
  end
  else if WriteType = 'd' then
    InputData := InputData + ' ' + inttostr(aPNode^.Data);
    TreeWrite(aPNode^.PLeft, WriteType);
    TreeWrite(aPNode^.PRight, WriteType);

  result := InputData;
end;

procedure FillTree(ArraySize: integer; MainArray:TreeArrT);
var
  i: integer;
begin
  for i := 1 to ArraySize do
    AddNode(PTree, MainArray[i]);
end;

end.
